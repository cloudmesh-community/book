% chktex-file 44
% chktex-file 8
% chktex-file 1

\chapter{Linux}
\label{C:linux}
\index{Linux}

\FILENAME\

\section{History}

LINUX is a reimplementation by the community of UNIX which was
developed in 1969 by Ken Thompson and Dennis Ritchie of Bell
Laboratories and rewritten in C. An important part of UNIX is what is
called the \textit{kernel} which allows the software to talk to
the hardware and utilize it. 

In 1991 Linus Trovalds started developing a Linux Kernel that was
initially targeted for PC's. This made it possible to run it on
Laptops and was later on further developed by making it a full
Operating system replacement for UNIX. 

\section{Shell}
\label{c:linux-commands}
\index{Shell}
\index{Terminal}

One of the most important features for us will be to access the
computer with the help of a \textit{shell}. The shell is typically run in
what is called a terminal and allows interaction to the computer with
commandline programs. 

There are many good tutorials out there that explain why one needs a
linux shell and not just a GUI. Randomly we picked the first one that
came up with a google query. This is not an endorsement for the material
we point to, but could be a worth while read for someone that has no
experience in Shell programming:

\URL{http://linuxcommand.org/lc3_learning_the_shell.php}

Certainly you are welcome to use other resources that may suite you
best. We will however summarize in table form a number of useful
commands that you may als find even as a RefCard.

\URL{http://www.cheat-sheets.org/\#Linux}

We provide in Table~\ref{T:shell-commands} a number of useful commands
that you want to explore. For more information simply type man and the
name of the command.


\begin{center}
\begin{longtable}{|p{4cm}|p{8cm}|}
\caption{Common commands}\label{T:shell-commands}\\

\hline
\multicolumn{1}{|p{4cm}|}{\textbf{Example}} & \multicolumn{1}{p{8cm}|}{\textbf{Description}} \\ 
\hline 
\endfirsthead

\multicolumn{2}{p{12cm}}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline 
\hline \multicolumn{1}{|p{4cm}|}{\textbf{Example}} & \multicolumn{1}{p{8cm}|}{\textbf{Description}} \\ 
\hline 
\endhead

\hline 
\multicolumn{2}{|r|}{{Continued on next page}} \\
\hline
\endfoot

%\hline 
\hline
\endlastfoot

  \multicolumn{2}{|l|}{\cellcolor{blue!15} Help Commands}\\
  \hline
  man \emph{command} & manual page for the \emph{command} \\
  apropos \textit{text} & list all commands that have text in it\\
  & \\

  \hline
  \multicolumn{2}{|l|}{\cellcolor{blue!15} File Commands}\\
  \hline
  ls & Directory listing\\
  ls -lisa & list details \\
  tree & list the directories in graphical form \\
  cd \emph{dirname} & Change directory to \emph{dirname} \\
  mkdir \emph{dirname} & create the directory \\
  rmdir \emph{dirname} & delete the directory \\
  pwd & print working directory \\
  rm \emph{file} & remove the file \\
  cp \emph{a} \emph{b} & copy file \emph{a} to \emph{b} \\
  mv \emph{a} \emph{b} & move/rename file \emph{a} to \emph{b}\\
  cat \emph{a} & print content of file\emph{a}\\
  cat -n \textit{filename}&  print content of file\emph{a} with line numbers\\
  less \emph{a} & print paged content of file \emph{a}\\
  head -5 \emph{a} & Display first 5 lines of file \emph{a}\\
  tail -5 \emph{a} & Display last 5 lines of file \emph{a}\\
  \verb|du -hs .| & show in human readable form the space used by the current
             directory\\
  \verb|df -h| & show the details of the disk file system \\
  wc \textit{filename}&  counts the word in a file \\
  sort \textit{filename} &  sorts the file \\
  uniq \textit{filename} &  displays only uniq entries in the file \\
  tar -xvf \textit{dir} &  tars up a compressed version of the directory \\
  rsync &  (assignment) \\
  gzip  \textit{filename}&  compresses the file \\
  gunzip  \textit{filename}& compresses the file \\
  bzip2 \textit{filename} &  compresses  the file with block-sorting \\
  bunzip2 \textit{filename} &  uncompresses  the file with block-sorting \\
  clear & clears the terminal screen \\
  touch \textit{filename} & change file access and modification times
  or if file does not exist creates file \\
  who & displays a list of users that are curretnly logged on, for
  each user the login name, date \& time of login, tty name, and
  hostname if not local are displayed\\
  whoami & displays the users effective id see also id \\
  echo -n \textit{string} & write specified arguments to standard output \\
  date & displays or sets date \& time, when invoked without arguments
  the current date and time are displayed\\
  logout & exit a given session\\
  exit & when issued at the shell promt the shell will exit and
  terminate any running jobs within the shell\\
  kill & terminate or signal a process by sending a signal to the
  specified process usually by the pid  \\
  ps & displays a header line followed by all processes that have
  controlling terminals\\
  sleep & suspends execution for an interval of time specified in seconds \\
  uptime & displays how long the system has been running \\
  time  \emph{command} & times the command execution in seconds\\
  find \textit{ / [-name] file-name.txt} &
  searchs a specificed path or directary with a given expression that
  tells the find utility what to find, if used as shown the find
  utility woud search the entire drive for a file named file-name.txt\\
  diff & compares files line by line \\
  hostname & prints the name of the current host system \\
  which & locates a program file in the users path \\
  tail & displays the last part of the file \\
  head & displays the first lines of a file \\
  top & displays a sorted list of system processes \\
  locate \textit{filename} & finds the path of a file\\
  grep \textit{'word'} \textit{filename} & finds all lines with the
  word in it\\
  grep -v \textit{'word'} \textit{filename} & finds all lines without the
  word in it\\
  chmod ug+rw \textit{filename} & change file modes or Access Control
  Lists. In this example user and group are changed to read and write\\
  chown & \\
  history & a buildin command to list the past commands\\
  sudo & \\
  su & \\
  uname & print the operating system name\\
  set -o emacs & tells the shell to use Emacs commands.\\
  & \\
  
  %\hline
  %\multicolumn{2}{|l|}{\cellcolor{blue!15} Search Commands}\\
  %\hline
  chmod go-rwx \textit{file} & changes the permission of the file \\
  chown \textit{username} \textit{file} & changes the ownership of the file \\
  chgrp \textit{group} \textit{file} & changes the group of a file\\
  & \\

  \hline
  \multicolumn{2}{|l|}{\cellcolor{blue!15} Search Commands}\\
  \hline
  \verb|fgrep "text" filename| &  searches the text in the given file \\
  \verb|grep -R "xyz" .| & recursively searches for xyz in all files \\
  \verb|find . -name "*.py"| &  find all files with \verb|.py| at the end \\
  & \\

  %\hline
  %\multicolumn{2}{|l|}{\cellcolor{blue!15} Process Commands}\\
  %\hline
  ps & list the running processes \\
  kill -9 1234 & kill the process with the id 1234 \\
  at &  (assignment) \\
  cron &  (assignment) \\
  crontab &  (assignment) \\
  & \\

  \hline
  \multicolumn{2}{|l|}{\cellcolor{blue!15} Device Commands}\\
  \hline
  mount /dev/cdrom /mnt/cdrom & mount a filesystem from a cd rom to /mnt/cdrom\\
  & \\

  \hline
  \multicolumn{2}{|l|}{\cellcolor{blue!15} System Commands}\\
  \hline
  users &  (assignment) \\
  who &  (assignment) \\
  whoami &  (assignment) \\
  dmesg &  (assignment) \\
  last &  (assignment) \\
  free -tm &  (assignment) \\
  uname &  (assignment) \\
  date &  prints the current date and time \\
  time \textit{command} &  prints the sys, real and user time \\
  shutdown -h ``shut down'' & (assignment) \\
  & \\

  \hline
  \multicolumn{2}{|l|}{\cellcolor{blue!15} Networking Commands}\\
  \hline
  ping &  (assignment) \\
  netstat &  (assignment) \\
  hostname &  (assignment) \\
  traceroute &  (assignment) \\
  ifconfig &  (assignment) \\
  & \\

  \hline
  \multicolumn{2}{|l|}{\cellcolor{blue!15} Internet Commands}\\
  \hline
  host &  (assignment) \\
  whois &  (assignment) \\
  dig &  (assignment) \\
  wget &  (assignment) \\
  curl &  (assignment) \\
  & \\

  \hline
  \multicolumn{2}{|l|}{\cellcolor{blue!15} Remote Access Commands}\\
  \hline
  ssh &  (assignment) \\
  scp &  (assignment) \\
  sftp &  (assignment) \\
  & \\


\end{longtable}
\end{center}

\section{Multi-command execution}

One of the important features is that one can execute multiple
commands in the shell.

To execute command 2 once command 1 has finished use

\begin{verbatim}
command1; command2
\end{verbatim}

To execute command 2 as soon as command 1 forwards output to stdout use

\begin{verbatim}
command1; command2
\end{verbatim}

To execute command 1 in the background use

\begin{verbatim}
command1 &
\end{verbatim}



\section{Keyboard Shortcuts}\label{keyboard-shortcuts}

These shortcuts will come in handy. Note that many overlap with emacs
short cuts.

\begin{tabular}{ll}
Keys     & Description  \\
\hline
Up Arrow & Show the previous command\\
Ctrl + z & Stops the current command  \\
         & Resume with fg in the foreground \\
         & Resume with bg in the background \\
Ctrl + c & Halts the current command\\
Ctrl + l & Clear the screen\\
Ctrl + a & Return to the start of the line\\
Ctrl + e & Go to the end of the line\\
Ctrl + k & Cut everything after the cursor to a special clipboard\\
Ctrl + y & Paste from the special clipboard \\
Ctrl + d & Logout of current session, similar to exit \\
\end{tabular}

\section{bashrc and bash\_profile}
\index{.bashrc}

Usage of a particular command and all the attributes associated with it,
use `man' command. Avoid using \verb|rm -r| command to delete files
recursively. A good way to avoid accidental deletion is to include the
following in your \verb|.bash_profile| file:

\begin{verbatim}
alias e=open_emacs
alias rm='rm -i'
alias mv='mv -i' 
alias h='history'
\end{verbatim}

More Information

\url{https://cloudmesh.github.io/classes/lesson/linux/refcards.html}

\section{Makefile}
\label{s:makefile}
\index{Makefile}

Makefiles allow developers to coordinate the execution of code
compilations. This not only includes C or C++ code, but any
translation from source to a final format. For us this could include
the creation of PDF files from latex sources, creation of docker
images, and the creation of cloud services and their deployment
through simple workflows represented in makefiles, or the coordination
of execution targets.

As makefiles include a simple syntax allowing structural dependencies
they can easily adapted to fulfill simple activities to be executed in
repeated fashion by developers.

An example of how to use Makefiles for docker is provided at
\url{http://jmkhael.io/makefiles-for-your-dockerfiles/}.

An example on how to use Makefiles for \LaTeX~is provided at
\url{https://github.com/cloudmesh/book/blob/master/Makefile}.

Makefiles include a number of rules that are defined by a target
name. Let us define a target called hello that prints out the string
``Hello World''.

\begin{lstlisting} 
hello:
    @echo "Hello World"
\end{lstlisting} 

Important to remember is that the commands after a target are not
indented just by spaces, but actually by a single TAB
character. Editors such as emacs will be ideal to edit such Makefiles,
while allowing syntax highlighting and easy manipulation of
TABs. Naturally other editros will do that also. Please chose your
editor of choice. One of the best features of targets is that they can
depend on other targets. Thus, iw we define

\begin{lstlisting} 
hallo: hello
    @echo "Hallo World"
\end{lstlisting} 

our makefile will first execute hello and than all commands in hallo.
As you can see this can be very useful for defining simple
dependencies. 

In addition we can define variables in a makefile such as 

\begin{lstlisting} 
HELLO="Hello World"

hello: 
    @echo $(HELLO)
\end{lstlisting} 
%$

and can use them in our text with \$ invocations.

Moreover, in sophisticated Makefiles, we could even make the targets
dependent on files and a target rouls could be defined that only
compiles those files that have changed since our last invokation of
the Makefile, saving potentially a lot of time. However, for our work
here we just use the most elementary makefiles.

For more information we recommend you to find out about it on the internet.
A convenient refrence card sis available at~\url{http://www.cs.jhu.edu/~joanne/unixRC.pdf}.


\subsubsection{Makefiles on Windows}
\index{Makefile!Windows}

Makefiles can easily be accessed also on windows while installing
gitbash. Please reer to the internet or search in this handbook for
more information about gitbash.



\section{Exercises}

\begin{exercise}
\label{E:Linux.1}
Familiarize yourself with the commands
\end{exercise}

\begin{exercise}
\label{E:Linux.2}
Find more commands that you find useful and add them to this page.
\end{exercise}

\begin{exercise}
\label{E:Linux.3}
Use the sort command to sort all lines of a file while removing
duplicates.
\end{exercise}

\begin{exercise}
\label{E:Linux.4} In Table~\ref{T:shell-commands} you will find a number
  of commands with (assignment). Develop descriptions that you will
  contribute and add to the manual with a pull request. Work in a team
  so that only one pull request is issued. Do not only provide the
  description, but also a real example as showcased within the table.
\end{exercise}

\begin{exercise}
\label{E:Linux.4} Should there be other commands listed in the table. If
  so which? Create a pull request for them. 
\end{exercise}

\begin{exercise}
\label{E:Linux.5} Write a section expplaining chmod
\end{exercise}

\begin{exercise}
\label{E:Linux.6} Write a section expplaining chown
\end{exercise}

\begin{exercise}
\label{E:Linux.7} Write a section expplaining su and sudo
\end{exercise}

\begin{exercise}
\label{E:Linux.8} Write a section explaining cron, at, and crontab
\end{exercise}
